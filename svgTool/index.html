<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PNG → SVG Tracer (2026 - Preprocessing Controls)</title>
  <style>
    body { font-family: system-ui, sans-serif; background: #0f0f15; color: #e0e0ff; padding: 20px; max-width: 1100px; margin: 0 auto; }
    h1 { color: #a5b4fc; }
    .container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin: 24px 0; }
    .panel { background: #1a1a2e; padding: 20px; border-radius: 12px; border: 1px solid #333366; }
    canvas, svg, #svgContainer { max-width: 100%; height: auto; background: #00000022; border: 1px solid #444; border-radius: 6px; min-height: 200px; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; margin: 16px 0; }
    button { padding: 10px 18px; background: #6366f1; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; }
    button:hover:not(:disabled) { background: #818cf8; }
    button:disabled { opacity: 0.5; cursor: not-allowed; background: #444; }
    .preset-btn { background: #4f46e5; }
    label { display: block; margin: 12px 0 4px; }
    input[type=range] { width: 180px; }
    input[type=checkbox] { margin-right: 8px; }
    .info, .status { font-size: 0.9rem; color: #aaa; }
    .status.error { color: #f66; }
    .status.success { color: #6f6; }
  </style>
</head>
<body>

<h1>PNG → SVG Tracer (with brightness & contrast)</h1>

<div class="container">
  <div class="panel">
    <h2>1. Load Image</h2>
    <input type="file" id="fileInput" accept="image/png,image/jpeg,image/bmp" />
    <p class="info">Best for high-contrast logos, icons, line art.<br>Use brightness/contrast to improve separation before tracing.</p>

    <h3>Preview (after adjustments)</h3>
    <canvas id="canvas" width="500" height="500"></canvas>
  </div>

  <div class="panel">
    <h2>2. Trace Settings & Preprocessing</h2>

    <div class="controls">
      <button id="traceBtn" disabled>Convert to SVG</button>
      <button id="downloadBtn" disabled>Download SVG</button>
      <button class="preset-btn" id="presetSharp">Sharp / Detailed Preset</button>
      <button class="preset-btn" id="presetSmooth">Smooth Logo Preset</button>
    </div>

    <div id="status" class="status"></div>

    <label>Threshold: <span id="threshVal">90</span></label>
    <input type="range" id="threshold" min="10" max="240" value="90" step="5" />

    <label>Blur (px): <span id="blurVal">1.5</span></label>
    <input type="range" id="blur" min="0" max="8" value="1.5" step="0.5" />

    <label>Brightness (%): <span id="brightVal">100</span></label>
    <input type="range" id="brightness" min="20" max="200" value="100" step="5" />

    <label>Contrast (%): <span id="contrastVal">120</span></label>
    <input type="range" id="contrast" min="50" max="300" value="120" step="10" />

    <label>Min path length (px): <span id="lenVal">3</span></label>
    <input type="range" id="minLength" min="1" max="40" value="3" step="1" />

    <label>Corner sharpness: <span id="alphaVal">0.00</span> (0 = sharp)</label>
    <input type="range" id="alphamax" min="0" max="1.333" value="0.0" step="0.05" />

    <label>Curve tolerance: <span id="tolVal">0.08</span> (lower = more detail)</label>
    <input type="range" id="opttolerance" min="0.01" max="2" value="0.08" step="0.02" />

    <label><input type="checkbox" id="opticurve" checked /> Fit smooth curves (uncheck = max detail / polygons)</label>

    <label><input type="checkbox" id="blackonwhite" checked /> Black is foreground (uncheck for white-on-black)</label>

    <label>Turn policy:
      <select id="turnPolicy">
        <option value="black">black</option>
        <option value="white">white</option>
        <option value="left">left</option>
        <option value="right">right</option>
        <option value="majority" selected>majority</option>
        <option value="minority">minority</option>
      </select>
    </label>

    <h3>Result (SVG preview)</h3>
    <div id="svgContainer">Load image & convert…</div>
  </div>
</div>

<script type="module">
  import { potrace, init as initPotrace } from 'https://cdn.jsdelivr.net/npm/esm-potrace-wasm@latest/+esm';

  const status = document.getElementById('status');
  status.textContent = 'Loading Potrace…';
  try {
    await initPotrace();
    status.textContent = 'Ready ✓';
    status.className = 'status success';
  } catch (e) {
    status.textContent = 'Load failed: ' + e.message;
    status.className = 'status error';
    console.error(e);
  }

  const fileInput    = document.getElementById('fileInput');
  const canvas       = document.getElementById('canvas');
  const ctx          = canvas.getContext('2d');
  const traceBtn     = document.getElementById('traceBtn');
  const downloadBtn  = document.getElementById('downloadBtn');
  const svgContainer = document.getElementById('svgContainer');

  let originalImage = null;

  // Live value displays
  const displays = {
    threshold:   document.getElementById('threshVal'),
    blur:        document.getElementById('blurVal'),
    brightness:  document.getElementById('brightVal'),
    contrast:    document.getElementById('contrastVal'),
    minLength:   document.getElementById('lenVal'),
    alphamax:    document.getElementById('alphaVal'),
    opttolerance: document.getElementById('tolVal')
  };

  Object.keys(displays).forEach(key => {
    const slider = document.getElementById(key);
    if (slider) {
      slider.oninput = e => {
        const val = e.target.value;
        displays[key].textContent = (key === 'alphamax' || key === 'opttolerance') ? Number(val).toFixed(2) : val;
      };
    }
  });

  // Presets (updated with brightness/contrast)
  document.getElementById('presetSharp').onclick = () => applyPreset('sharp');
  document.getElementById('presetSmooth').onclick = () => applyPreset('smooth');

  function applyPreset(type) {
    if (type === 'sharp') {
      document.getElementById('threshold').value = 100;
      document.getElementById('blur').value = 1.0;
      document.getElementById('brightness').value = 110;
      document.getElementById('contrast').value = 140;
      document.getElementById('minLength').value = 2;
      document.getElementById('alphamax').value = 0.0;
      document.getElementById('opttolerance').value = 0.05;
      document.getElementById('opticurve').checked = false;
      document.getElementById('turnPolicy').value = 'minority';
    } else { // smooth
      document.getElementById('threshold').value = 80;
      document.getElementById('blur').value = 2.5;
      document.getElementById('brightness').value = 90;
      document.getElementById('contrast').value = 110;
      document.getElementById('minLength').value = 8;
      document.getElementById('alphamax').value = 1.0;
      document.getElementById('opttolerance').value = 0.2;
      document.getElementById('opticurve').checked = true;
      document.getElementById('turnPolicy').value = 'majority';
    }
    // Update displayed values
    Object.keys(displays).forEach(k => {
      const v = document.getElementById(k)?.value ?? '—';
      displays[k].textContent = (k === 'alphamax' || k === 'opttolerance') ? Number(v).toFixed(2) : v;
    });
  }

  fileInput.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    status.textContent = 'Image loaded';
    status.className = 'status';

    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      img.onload = () => {
        originalImage = img;
        let w = img.width, h = img.height;
        const maxDim = 900;
        if (w > maxDim || h > maxDim) {
          if (w > h) { h = Math.round(maxDim * h / w); w = maxDim; }
          else { w = Math.round(maxDim * w / h); h = maxDim; }
        }
        canvas.width = w; canvas.height = h;
        redrawPreview(); // initial draw with defaults
        traceBtn.disabled = false;
        downloadBtn.disabled = true;
        svgContainer.innerHTML = 'Ready — adjust settings & press Convert';
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  };

  // Helper to redraw preview with current adjustments (optional visual feedback)
  function redrawPreview() {
    if (!originalImage) return;
    ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

    const blurPx     = parseFloat(document.getElementById('blur').value);
    const brightPct  = parseFloat(document.getElementById('brightness').value);
    const contrastPct = parseFloat(document.getElementById('contrast').value);

    let filterStr = '';
    if (blurPx > 0)     filterStr += `blur(${blurPx}px) `;
    if (brightPct !== 100)  filterStr += `brightness(${brightPct}%) `;
    if (contrastPct !== 100) filterStr += `contrast(${contrastPct}%) `;

    if (filterStr) {
      ctx.filter = filterStr.trim();
      ctx.drawImage(canvas, 0, 0);
      ctx.filter = 'none';
    }
  }

  // Attach redraw to sliders so user sees changes live
  ['blur', 'brightness', 'contrast'].forEach(id => {
    document.getElementById(id).oninput = () => redrawPreview();
  });

  traceBtn.onclick = async () => {
    if (!originalImage) return;
    status.textContent = 'Preprocessing & tracing…';
    status.className = 'status';

    // Start from original
    ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);

    // Apply all filters in sequence
    const blurPx      = parseFloat(document.getElementById('blur').value);
    const brightPct   = parseFloat(document.getElementById('brightness').value);
    const contrastPct = parseFloat(document.getElementById('contrast').value);

    let filterStr = '';
    if (blurPx > 0)     filterStr += `blur(${blurPx}px) `;
    if (brightPct !== 100)  filterStr += `brightness(${brightPct}%) `;
    if (contrastPct !== 100) filterStr += `contrast(${contrastPct}%) `;

    if (filterStr) {
      ctx.filter = filterStr.trim();
      ctx.drawImage(canvas, 0, 0);
      ctx.filter = 'none';
    }

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    try {
      const params = {
        turnpolicy:   document.getElementById('turnPolicy').value,
        turdsize:     parseInt(document.getElementById('minLength').value),
        alphamax:     parseFloat(document.getElementById('alphamax').value),
        opticurve:    document.getElementById('opticurve').checked,
        opttolerance: parseFloat(document.getElementById('opttolerance').value),
        threshold:    parseInt(document.getElementById('threshold').value) / 255,
        blackonwhite: document.getElementById('blackonwhite').checked,
      };

      console.log('Tracing params:', params);

      const svg = await potrace(imageData, params);

      if (!svg || svg.length < 300) throw new Error('Empty/weak result – try higher contrast or different threshold');

      svgContainer.innerHTML = svg;

      downloadBtn.disabled = false;
      downloadBtn.onclick = () => {
        const blob = new Blob([svg], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'traced.svg';
        a.click();
        URL.revokeObjectURL(url);
      };

      status.textContent = 'Done ✓';
      status.className = 'status success';
      if (!params.opticurve) status.textContent += ' (polygon mode)';
    } catch (err) {
      console.error(err);
      status.textContent = 'Error: ' + (err.message || 'Failed');
      status.className = 'status error';
      svgContainer.innerHTML = '<p style="color:#f66">Failed. Try more contrast, higher threshold, or less blur.</p>';
    }
  };
</script>
</body>
</html>
